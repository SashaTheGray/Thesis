#!/bin/bash

# -----------------------------------###----------------------------------- #
#                                  THESIS                                   #
#                               ------------                                #
#                       A personal forward operating base                   #
#                           and a Head in the Clouds                        #
# -----------------------------------###----------------------------------- #
#                                MIT License                                #
#                                                                           #
# Copyright (c) 2022 Alexander Robertson                                    #
#                                                                           #
# Permission is hereby granted, free of charge, to any person obtaining     #
# a copy of this software                                                   #
# and associated documentation files (the "Software"),                      #
# to deal in the Software without restriction, including without limitation #
# the rights to use, copy, modify, merge, publish, distribute, sublicense,  #
# and/or sell copies of the Software, and to permit persons to whom         #
# the Software is furnished to do so, subject to the following conditions:  #
#                                                                           #
# The above copyright notice and this permission notice shall be included   #
# in all copies or substantial portions of the Software.                    #
#                                                                           #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,           #
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO                          #
# THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE       #
# AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS   #
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,                      #
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,        #
# OUT OF OR IN CONNECTION WITH THE SOFTWARE                                 #
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                             #
# -----------------------------------###----------------------------------- #
#                             TABLE OF CONTENTS                             #
# -----------------------------------###----------------------------------- #
#                                                                           #
#               I.      GLOBALS                                             #
#               II.     FUNCTIONS                                           #
#               III.    DETERMINE SYSTEM PACKAGE MANAGER                    #
#               IV.     INSTALL PACKAGES                                    #
#               V.      STOW SYMLINKS                                       #
#               VI.     SET ZSH AS SHELL                                    #
#                                                                           #
# -----------------------------------###----------------------------------- #





# ---------- #
# I. GLOBALS #
# ---------- #

# Log files.
declare -r ERRORS="$HOME/.config/thesis/installer/errors.log"

# System package manager.
PACKAGE_MANAGER="NONE"

# Packages to be installed via the package manager.
declare -ar PKG_MGR_PACKAGES=(
    git         # Version control system.
    zsh         # Shell alternative.
    tmux        # Terminal multiplexer.
    stow        # Symlink farm.
    bat         # A better cat command.
    fzf         # Fuzzy finder.
    unzip	    # Extraction tool.
    nodejs      # Javascript runtime.
    cargo       # Rust package manager.
    shellcheck  # Bash linter.
    ripgrep     # Recursive search tool.
)

# Packages to be installed via pip.
declare -ar PIP_PACKAGES=(
    flake8      # Python code linter.
    autopep8    # Python formatter.
    beautysh    # Bash code formatter.
)

# Packages to be installed via npm.
declare -ar NPM_PACKAGES=(
    prettier    # Formatter -> https://www.npmjs.com/package/prettier.
    typescript  # Typescript compiler.
)

# Packages to be installed via cargo.
declare -ar CARGO_PACKAGES=(
    stylua      # Lua code formatter.
)

# Declare a system -> package manager associative array.
declare -Ar PM_LOOKUP=(
    [/etc/debian_version]="apt"
)

# Declare a package manager -> install command associative array.
declare -Ar PMIC=(
    [apt]="apt -y install"
    [nala]="nala -y install"
)

# https://dev.to/ifenna__/adding-colors-to-bash-scripts-48g4
declare -Ar COLOURS=(
    [none]="\e[0m"
    [black]="\e[30m"
    [red]="\e[31m"
    [green]="\e[32m"
    [yellow]="\e[33m"
    [blue]="\e[34m"
    [magenta]="\e[35m"
    [cyan]="\e[36m"
    [light_gray]="\e[37m"
    [gray]="\e[90m"
    [light_red]="\e[91m"
    [light_green]="\e[92m"
    [light_yellow]="\e[93m"
    [light_blue]="\e[94m"
    [light_magenta]="\e[95m"
    [light_cyan]="\e[96m"
    [white]="\e[97m"
)


# ------------- #
# II. FUNCTIONS #
# ------------- #

###################################################
# Echo signed and colored notifications           #
# --------------------------------------          #
#                                                 #
# Arguments:                                      #
#   type        -   operation | success | failure #
#   message     -   message to echo               #
#   indent      -   true | false -> default=false #
###################################################
notify ()
{
    # Parse arguments.
    local type=${1:-""}
    local message=${2:-""}
    local indent=${3:-false}

    # Placeholders.
    local colour="NONE"
    local sign="NONE"

    # Deduce color and sign for the notification.
    case "$type" in
        "operation")
            colour=${COLOURS[blue]}
            sign="[*] "
            ;;
        "success")
            colour=${COLOURS[light_green]}
            sign="[+] "
            ;;
        "failure")
            colour=${COLOURS[red]}
            sign="[-] "
            ;;
        "warning")
            colour=${COLOURS[magenta]}
            sign="[!] "
            ;;
        "debug")
            colour=${COLOURS[yellow]}
            sign="[?] "
            ;;
        "info")
            colour=${COLOURS[cyan]}
            sign="[i] "
            ;;
        *)
            colour=${COLOURS[none]}
            sign=""
            ;;
    esac

    # Echo notification.
    if [ "$indent" = true ];
    then
        echo -e "\t$colour$sign$message${COLOURS['none']}"
    else
        echo -e "$colour$sign$message${COLOURS['none']}"
    fi

}

########################################################
# Install packages                                     #
# -----------------                                    #
#                                                      #
# Arguments:                                           #
#   package_manager -   Package manager to use         #
#   packages        -   Array of packages to install   #
#                                                      #
# Globals:                                             #
#   PMIC            -   Pkg mgr pkg install command    #
########################################################
install_packages ()
{
    # Parse arguments.
    local pkg_mgr=${1:-"NONE"}
    shift
    local pkgs=("$@")

    # Ensure that correct arguments are passed.
    if [[ ${pkgs[*]} = "NONE" ]] || [[ $pkg_mgr = "NONE" ]];
    then
        notify \
            failure \
            "Cannot install packages $pkg_mgr -> Arguments missing"
        return 1
    elif [[ -z ${#pkgs[@]} ]] || [[ -z $pkg_mgr ]];
    then
        notify \
            failure \
            "Cannot install $pkg_mgr packages -> Arguments can't be empty"
        return 1
    fi

    # Notify.
    local len=${#pkgs[@]}
    local noun
    if [[ $len -eq 1 ]]; then noun="package"; else noun="packages"; fi
    notify operation "Thesis is installing $len $pkg_mgr $noun"

    # Install packages.
    for i in "${!pkgs[@]}";
    do
        local package=${pkgs[i]}

        # Install package.
        "${PMIC[$pkg_mgr]}" "$package" 2> "$ERRORS"

        # Some packages have different names for commands.
        if [[ $package = "bat" ]];
        then
            package="batcat"
        elif [[ $package = "typescript" ]];
        then
            package="tsc"
        fi

        # Check if installation was successful.
        local command
        command="$package --version &> /dev/null || \
            $package -V &> /dev/null || \
            $package version &> /dev/null || \
            $package --help &> /dev/null || \
            $package -hh &> /dev/null)"
        if [ "$command" ]; then type=success; else type=failure; fi

        # Notify success scenario.
        notify $type "${pkgs[$i]} \t($(( "$i" + 1 ))/$len)" true
    done

    return 0
}


# ------------------------------------- #
# III. DETERMINE SYSTEM PACKAGE MANAGER #
# ------------------------------------- #

# Use sudo here to require su-privileges for the program.
clear
sudo echo -e "[THESIS START]\n"

notify operation "Thesis is determining system's package manager"
for file in "${!PM_LOOKUP[@]}";
do
    if [[ -f $file ]]; then
        PACKAGE_MANAGER=${PM_LOOKUP[$file]}
        notify success "Found $PACKAGE_MANAGER" true
        break
    fi
done

# Abort if no suitable package manager was found.
if [ "$PACKAGE_MANAGER" = "NONE" ]; then
    notify debug "$PACKAGE_MANAGER"
    notify failure "Cannot determine system's package manager" true
    notify warning "Aborting installation ..."
    echo "--- THESIS ---"
    exit 1
fi

# Set up Nala package manager instead of apt if available.
if command -v nala &> /dev/null && [ "$PACKAGE_MANAGER" = "apt" ];
then
    PACKAGE_MANAGER="nala"
    notify info "Using nala instead of apt" true
fi



# -------------------- #
# IV. INSTALL PACKAGES #
# -------------------- #

# Add nodejs source as Debian mirrors contain old version.
if [ "$PACKAGE_MANAGER" = "apt" ] || [ "$PACKAGE_MANAGER" = "nala" ];
then
    curl -sL https://deb.nodesource.com/setup_18.x | sudo bash &> /dev/null
fi

# Install neovim from appimage.
notify operation "Thesis is installing Neovim from appimage"
SOURCE_DOMAIN="https://github.com"
SOURCE_DIR="/neovim/neovim/releases/latest/download/nvim.appimage"
NEOVIM_SOURCE="$SOURCE_DOMAIN$SOURCE_DIR"

NEOVIM_DEST=$HOME/.local/bin
NEOVIM_IMAGE="$NEOVIM_DEST/nvim"

if [ ! -d "$NEOVIM_DEST" ];
then
    mkdir -p "$NEOVIM_DEST"
fi

if curl -sL $NEOVIM_SOURCE -o "$NEOVIM_IMAGE" 2> "$ERRORS";
then
    chmod u+x "$NEOVIM_IMAGE"
    command -v nvim &> /dev/null
    notify success "Thesis installed Neovim" true
else
    notify failure "Thesis failed to install Neovim" true
fi

# Install package manager packages.
install_packages "$PACKAGE_MANAGER" "${PKG_MGR_PACKAGES[@]}"

# Install pip packages.
install_packages pip "${PIP_PACKAGES[@]}"

# Install npm packages.
install_packages npm "${NPM_PACKAGES[@]}"

# Install cargo packages.
install_packages cargo "${CARGO_PACKAGES[@]}"


# ---------------- #
# V. STOW SYMLINKS #
# ---------------- #

notify operation "Thesis is stowing symlinks"
command="cd $HOME/.config/thesis/packages/ && \
    stow --target=$HOME * || \
    notify warning 'Could not stow symlinks' true"

if eval "$command";
then
    notify success "Symlinks stowed" true
fi

# -------------------- #
# VI. SET ZSH AS SHELL #
# -------------------- #

if [ "$SHELL" != "/usr/bin/zsh" ] ; then

    # Get path of the zsh executable.
    zsh_path=$(command -v zsh)

    # Change shell for $USER to zsh.
    sudo chsh -s "$zsh_path" "$USER"

    # Explictly set the current shell as zsh.
    export SHELL=$zsh_path

    notify success "ZSH set as shell"
    notify debug "Please run 'source $HOME/.zshenv' to finish setup"
fi

echo -e "\n[THESIS END]"
